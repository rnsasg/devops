# Outlier detection
The second type of health checking is called passive health checking. The process called outlier detection is a form of passive health checking. It’s “passive” because Envoy isn’t “actively” sending any requests to determine the health of the endpoints. Instead, Envoy observes the performance of different endpoints to determine if they are healthy or not. If the endpoints are deemed unhealthy, they are removed or ejected from the healthy load-balancing pool.

The endpoints’ performance is determined through consecutive failures, temporal success rate, latency, and so on.

For outlier detection to work, we need filters to report the errors, timeouts, and resets. Currently, four filters support outlier detection: HTTP router, TCP proxy, Redis proxy, and Thrift proxy.

Detected errors fall into two categories, based on the point of origin:

1. Externally originated errors
These transaction-specific errors occur on the upstream server in response to the received request. The errors are generated on the upstream host after Envoy has connected to it successfully. E.g., the endpoint responds with HTTP 500.

2. Locally originated errors
Envoy generates these errors in response to an event that interrupted or prevented communication with the upstream host, e.g., timeouts, TCP resets, inability to connect to a specified port, etc.

The errors also depend on the filter type. For example, the HTTP router filter can detect two kinds of errors. In contrast, the TCP proxy filter doesn’t understand any protocol above the TCP layer and only reports the locally originated errors.

In the configuration, we can specify whether we can distinguish between local and externally generated errors (using split_external_local_origin_errors field). This allows us to track the errors by separate counters and configure the outlier detection to react to locally generated errors and ignore the externally generated errors, and vice-versa. The default mode is for the errors not to be split (i.e. split_external_local_origin_errors is false).

## Endpoint ejection
Envoy will check if it needs to be ejected from the healthy load-balancing pool when an endpoint is determined to be an outlier. Envoy ejects the outlier (unhealthy) endpoint immediately if no endpoints were ejected. Otherwise, it checks the max_ejection_percent setting to ensure the number of ejected endpoints is below the configured threshold. The endpoint won’t be ejected if more than max_ejection_percent hosts were already ejected.

Each endpoint gets ejected for a predetermined amount of time. We can configure the ejection time using the base_ejection_time value. This value is multiplied by the number of times the endpoint has been ejected in a row. If the endpoints continue to fail, they’ll get ejected for longer and longer periods. The second set here is called max_ejection_time . It controls the maximum time endpoints get ejected for - i.e., the maximum time endpoints will ever get ejected is specified in the max_ejection_time value.

Envoy checks the health of each endpoint at an interval specified in the interval field. For every check the endpoint is healthy, the ejection multiplier gets decremented. After the ejection time passes, the endpoint automatically returns to the healthy load-balancing pool.

Now that we understand the basics of outlier detection and endpoint ejection let’s look at the different outlier detection methods.

## Detection types
Envoy supports the following five outlier detection types:

1. Consecutive 5xx
This detection type takes into account all generated errors. Envoy internally maps any errors generated by non-HTTP filters to HTTP 5xx codes.

When error types are split, this detection type only counts the externally originated errors and ignores the locally originated errors. If the endpoint is an HTTP server, only 5xx types of errors are considered.

If an endpoint returns a certain number of 5xx errors, the endpoint gets ejected. The consecutive_5xx value controls the number of consecutive 5xx errors.

```yaml
  clusters:
  - name: my_cluster_name
    outlier_detection:
      interval: 5s
      base_ejection_time: 15s
      max_ejection_time: 50s
      max_ejection_percent: 30
      consecutive_5xx: 10
      ...
```

The above outlier detection will eject a failing endpoint once it fails ten times. The failing endpoint gets ejected for 15 seconds (base_ejection_time). The maximum time a single endpoint gets ejected in the case of multiple ejections is 50 seconds (max_ejection_time). Before a failing endpoint gets ejected, Envoy checks if more than 30% of endpoints were already ejected (max_ejection_percent) and decides whether to eject the failing endpoint or not.

2. Consecutive gateway failure
The consecutive gateway failure type is similar to the consecutive 5xx type. It considers a subset of 5xx errors, called “gateway errors” (e.g., 502, 503, or 504 status codes) and local origin failures such as timeouts, TCP reset, etc.

This detection type considers the gateway errors in the split mode and is supported only by the HTTP filter. The number of consecutive errors is configurable with the consecutive_gateway_failure field.

```yaml
  clusters:
  - name: my_cluster_name
    outlier_detection:
      interval: 5s
      base_ejection_time: 15s
      max_ejection_time: 50s
      max_ejection_percent: 30
      consecutive_gateway_failure: 10
      ...
```

3. Consecutive local origin failure
This type is only enabled in the split mode (split_external_local_origin_errors is true), and it only considers locally originated errors. The number of consecutive failures is configurable via the consecutive_local_origin_failure field. If not provided, it defaults to 5.

```yaml
  clusters:
  - name: my_cluster_name
    outlier_detection:
      interval: 5s
      base_ejection_time: 15s
      max_ejection_time: 50s
      max_ejection_percent: 30
      consecutive_local_origin_failure: 10
      ...
```

4. Success rate
The success rate outlier detection aggregates success rate data from every endpoint in the cluster. Based on the success rate, it then ejects the endpoints at given intervals. All errors are considered in the default mode, while the external and locally originated errors get treated separately in the split mode.

With the success_rate_request_volume value, we can set the minimum request volume. If the request volume is less than the one specified in the field, the success rate for the host will not be calculated. Similarly, we can use the success_rate_minimum_hosts to set the number of endpoints with the minimum required request volume. If the number of endpoints with minimum required request volume is less than the value set in success_rate_minimum_hosts, Envoy will not perform the outlier detection.

The success_rate_stdev_factor is used to determine the ejection threshold. The ejection threshold is the difference between the mean success rate and the product of this factor and the standard deviation of the mean success rate:

mean - (stdev * success_rate_stdev_factor)
This factor is divided by a thousand to get a double. If the desired factor is 1.9, the runtime value should be 1900.

5. Failure percentage
The failure percentage outlier detection is similar to the success rate. The difference is that it doesn’t rely on the mean success rate of the cluster as a whole. Instead, it compares the value to a user-configured threshold in the failure_percentage_threshold field. If the failure percentage of a given host is greater or equal to this value, the host gets ejected.

The minimum hosts and request volume can be configured using the failure_percentage_minimum_hosts and failure_percentage_request_volume.